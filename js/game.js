// Generated by CoffeeScript 1.6.3
(function() {
  var GameCanvas, KeyboardController, PlayField, Point, Snake, TastyPoint, arrayHas, dotsize, find, gameCanvas, init, initial_snake_length, keyMap, keyboardController, max_tasty_points, min_tasty_point_life, playField, randomNumber, readyStateCheckInterval, registerHandler, snake, start, stop, tick, tick_period, ticker, ticks;

  randomNumber = function(options) {
    return Math.floor(Math.random() * options);
  };

  find = function(array, test) {
    var i, _i, _ref;
    for (i = _i = 0, _ref = array.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (test(array[i])) {
        return array[i];
      }
    }
  };

  arrayHas = function(array, test) {
    return find(array, test) !== void 0;
  };

  GameCanvas = (function() {
    function GameCanvas(canvas, width, height) {
      this.canvas = canvas;
      this.width = width;
      this.height = height;
      this.context = this.canvas.getContext('2d');
      this.xScale = this.canvas.width / width;
      this.yScale = this.canvas.height / height;
    }

    GameCanvas.prototype.clear = function() {
      return this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };

    GameCanvas.prototype.drawPixel = function(x, y, color) {
      this.context.fillStyle = color;
      return this.context.fillRect(x * this.xScale, y * this.yScale, this.xScale, this.yScale);
    };

    GameCanvas.prototype.beginPath = function(x, y, color) {
      this.context.fillStyle = 'none';
      this.context.strokeStyle = color;
      this.context.lineWidth = (this.xScale + this.yScale) / 2;
      return this.context.beginPath(x * this.xScale, y * this.yScale);
    };

    GameCanvas.prototype.lineTo = function(x, y) {
      return this.context.lineTo(x * this.xScale + 12, y * this.yScale + 12);
    };

    GameCanvas.prototype.endPath = function() {
      return this.context.stroke();
    };

    return GameCanvas;

  })();

  Point = (function() {
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    Point.prototype.set = function(x, y) {
      this.x = x;
      this.y = y;
    };

    Point.prototype.add = function(otherPoint) {
      return new Point(this.x + otherPoint.x, this.y + otherPoint.y);
    };

    Point.prototype.addTo = function(otherPoint) {
      return this.set(this.x + otherPoint.x, this.y + otherPoint.y);
    };

    Point.prototype.isEqualTo = function(otherPoint) {
      return this.x === otherPoint.x && this.y === otherPoint.y;
    };

    return Point;

  })();

  TastyPoint = (function() {
    function TastyPoint(location) {
      this.location = location;
      this.life = min_tasty_point_life + randomNumber(min_tasty_point_life);
      this.scale = dotsize;
    }

    TastyPoint.prototype.update = function() {
      return this.life--;
    };

    TastyPoint.prototype.is_alive = function() {
      return this.life > 0;
    };

    TastyPoint.prototype.draw = function() {
      return gameCanvas.drawPixel(this.location.x, this.location.y, '#58d68d');
    };

    return TastyPoint;

  })();

  PlayField = (function() {
    function PlayField(width, height) {
      this.width = width;
      this.height = height;
      this.tasty_points = [];
    }

    PlayField.prototype.update = function() {
      var i;
      i = 0;
      while (i < this.tasty_points.length) {
        this.tasty_points[i].update();
        if (!this.tasty_points[i].is_alive()) {
          this.removeTastyPoint(this.tasty_points[i]);
        } else {
          i++;
        }
      }
      if (this.tasty_points.length < max_tasty_points && randomNumber(20) === 3) {
        return this.spawnTastyPoint();
      }
    };

    PlayField.prototype.spawnTastyPoint = function() {
      var location, tasty_point, _results;
      location = new Point(0, 0);
      _results = [];
      while (true) {
        location.set(randomNumber(playField.width), randomNumber(playField.height));
        if (this.tastyPointAt(location) === void 0 && !snake.hasSegmentAt(location)) {
          tasty_point = new TastyPoint(location);
          this.tasty_points.push(tasty_point);
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    PlayField.prototype.removeTastyPoint = function(tasty_point) {
      var index;
      index = this.tasty_points.indexOf(tasty_point);
      if (index >= 0) {
        return this.tasty_points.splice(index, 1);
      }
    };

    PlayField.prototype.munchTastyPoint = function(point) {
      var tasty_point;
      tasty_point = this.tastyPointAt(point);
      if (tasty_point != null) {
        this.removeTastyPoint(tasty_point);
        return true;
      } else {
        return false;
      }
    };

    PlayField.prototype.tastyPointAt = function(point) {
      return find(this.tasty_points, function(tasty) {
        return tasty.is_alive() && tasty.location.isEqualTo(point);
      });
    };

    PlayField.prototype.draw = function() {
      gameCanvas.clear();
      return this.tasty_points.forEach(function(tasty_point) {
        return tasty_point.draw();
      });
    };

    return PlayField;

  })();

  Snake = (function() {
    function Snake(length) {
      var i, x, y, _i;
      this.length = length;
      this.segments = [];
      this.is_alive = true;
      this.direction = new Point(1, 0);
      this.lastDirection = this.direction;
      x = Math.round(playField.width / 2);
      y = Math.round(playField.height / 2);
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        this.segments.push(new Point(x - i, y));
      }
    }

    Snake.prototype.head = function() {
      return this.segments[0];
    };

    Snake.prototype.tail = function() {
      return this.segments[this.segments.length - 1];
    };

    Snake.prototype.hasSegmentAt = function(location) {
      return arrayHas(this.segments, function(segment) {
        return segment.isEqualTo(location);
      });
    };

    Snake.prototype.draw = function() {
      gameCanvas.beginPath(this.head().x, this.head().y, '#58d68d');
      this.segments.forEach(function(segment) {
        return gameCanvas.lineTo(segment.x, segment.y);
      });
      gameCanvas.endPath();
      return gameCanvas.drawPixel(this.head().x, this.head().y, '#e74c3c');
    };

    Snake.prototype.move = function() {
      var i, _i, _ref;
      if (this.willMeetItsDoom()) {
        return this.is_alive = false;
      } else {
        if (this.willMunchATastyPoint()) {
          this.grow(5);
        }
        for (i = _i = _ref = this.segments.length - 1; _ref <= 0 ? _i < 0 : _i > 0; i = _ref <= 0 ? ++_i : --_i) {
          this.segments[i].set(this.segments[i - 1].x, this.segments[i - 1].y);
        }
        this.head().addTo(this.direction);
        return this.lastDirection = this.direction;
      }
    };

    Snake.prototype.willMeetItsDoom = function() {
      var newHead;
      newHead = this.head().add(this.direction);
      if (newHead.x < 0 || newHead.x >= playField.width || newHead.y < 0 || newHead.y >= playField.height) {
        return true;
      }
      if (this.hasSegmentAt(newHead)) {
        return true;
      }
      return false;
    };

    Snake.prototype.willMunchATastyPoint = function() {
      var newHead;
      newHead = this.head().add(this.direction);
      return playField.munchTastyPoint(newHead);
    };

    Snake.prototype.grow = function(length) {
      var i, _i, _results;
      _results = [];
      for (i = _i = 1; 1 <= length ? _i <= length : _i >= length; i = 1 <= length ? ++_i : --_i) {
        _results.push(this.segments.push(new Point(this.tail().x, this.tail().y)));
      }
      return _results;
    };

    Snake.prototype.changeDirection = function(direction) {
      var d;
      if (direction != null) {
        d = this.lastDirection.add(direction);
        if (d.x !== 0 || d.y !== 0) {
          return this.direction = direction;
        }
      }
    };

    return Snake;

  })();

  keyMap = {
    '37': new Point(-1, 0),
    '39': new Point(1, 0),
    '38': new Point(0, -1),
    '40': new Point(0, 1)
  };

  KeyboardController = (function() {
    function KeyboardController() {
      this.keysDown = [];
      document.onkeydown = function(event) {
        return keyboardController.keyDown(event);
      };
      document.onkeyup = function(event) {
        return keyboardController.keyUp(event);
      };
    }

    KeyboardController.prototype.keyDown = function(event) {
      var key;
      key = (event || window.event).keyCode;
      if (this.keysDown.indexOf(key) === -1) {
        this.keysDown.push(key);
        return snake.changeDirection(keyMap[key]);
      }
    };

    KeyboardController.prototype.keyUp = function(event) {
      var index, key;
      key = (event || window.event).keyCode;
      index = this.keysDown.indexOf(key);
      if (index >= 0) {
        return this.keysDown.splice(index, 1);
      }
    };

    return KeyboardController;

  })();

  tick_period = 100;

  dotsize = 24;

  min_tasty_point_life = 50;

  max_tasty_points = 10;

  initial_snake_length = 5;

  ticker = ticks = playField = gameCanvas = snake = keyboardController = null;

  readyStateCheckInterval = setInterval(function() {
    if (document.readyState === "complete") {
      init();
      return clearInterval(readyStateCheckInterval);
    }
  }, 10);

  registerHandler = function(node, event, handler) {
    if (typeof node.addEventListener === "function") {
      return node.addEventListener(event, handler, false);
    } else {
      return node.attachEvent("on" + event, handler);
    }
  };

  init = function() {
    var startButton;
    startButton = document.getElementById('start');
    return registerHandler(startButton, 'click', function() {
      return start();
    });
  };

  start = function() {
    stop();
    playField = new PlayField(720 / dotsize, 480 / dotsize);
    gameCanvas = new GameCanvas(document.getElementById('game'), playField.width, playField.height);
    snake = new Snake(initial_snake_length);
    keyboardController = new KeyboardController();
    ticks = 0;
    return ticker = setInterval(tick, tick_period);
  };

  stop = function() {
    if (ticker != null) {
      return clearInterval(ticker);
    }
  };

  tick = function() {
    ticks++;
    if (snake.is_alive) {
      console.log('snake move');
      snake.move();
    }
    playField.update();
    playField.draw();
    return snake.draw();
  };

}).call(this);
